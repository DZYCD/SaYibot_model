{
  "adding": {
    "target": "python二分sqrt"
  },
  "杭电账号": {
    "content": "team658 629321"
  },
  "割边": {
    "content": "void tarjan(int id,int last){//割边算法\r\n    s.push(id);\r\n    order[id] = ++timeStamp;\r\n    low[id] = order[id];\r\n    for(auto i:node[id]){\r\n        if(i.second==(last^1))continue;\r\n        if(order[i.first]==0) {\r\n            tarjan(i.first, i.second);\r\n            low[id] = min(low[i.first], low[id]);\r\n        }\r\n        else{\r\n            low[id] = min(low[id],order[i.first]);\r\n        }\r\n    }\r\n    if(order[id] == low[id]){\r\n        ans++;\r\n        father[ans].push_back(id);\r\n        while(s.top() != id){\r\n            father[ans].push_back(s.top());\r\n            s.pop();\r\n            }\r\n        /[CQ:face,id=79]is[s.top()]=0;\r\n        s.pop();\r\n    }\r\n}\r\nvoid solve() {\r\n    int m;\r\n    cin>>n>>m;\r\n    for(int i = 1;i<=m;i++){\r\n        int u,v;\r\n        cin>>u>>v;\r\n        //cout<<u<<' '<<v<<endl;\r\n        node[u].push_back({v,i<<1});\r\n        node[v].push_back({u,i<<1|1});\r\n    }\r\n    for(int i = 1;i<=n;i++)if(order[i]==0){tarjan(i,0);}\r\n    cout<<ans<<endl;\r\n    for(int i = 1;i<=ans;i++){\r\n        cout<<father[i].size()<<' ';\r\n        for(auto p: father[i])cout<<p<<' ';\r\n        cout<<endl;\r\n    }\r\n}"
  },
  "外卖": {
    "content": "说实话，外卖在有些时候特别关键。尤其是在夜里食堂关门的时候。。"
  },
  "大一战绩": {
    "content": "蓝桥杯国二 天梯赛国三 睿抗国一 百度之星省三 马蹄杯省一 icpc铜牌 ccpc银牌 三创赛校一 苏嵌杯校三  icpc优胜 四级过差一个校二就是大满贯 共加14.75"
  },
  "割点": {
    "content": "void tarjan(int id,int last){\r\n    low[id] = ++timeStamp;\r\n    order[id] = low[id];\r\n    int child = 0;\r\n    p.push(id);\r\n    for(int i : node[id]){\r\n        if(!order[i]){\r\n            child++;\r\n            tarjan(i,id);\r\n            low[id] = min(low[id],low[i]);\r\n            if(low[i] >= order[id]){\r\n                ans++;int tmp;\r\n                do{\r\n                    tmp = p.top();\r\n                    p.pop();\r\n                    ans_list[ans].push_back(tmp);\r\n                }while(tmp!=i);\r\n                ans_list[ans].push_back(id);\r\n            }\r\n        }\r\n        else{\r\n            if(order[i]<order[id] &amp;&amp; id!=last)low[id] = min(low[id],order[i]);\r\n        }\r\n    }\r\n    if(id==par &amp;&amp; child==0){\r\n        ans++;\r\n        ans_list[ans].push_back(id);\r\n    }\r\n}"
  },
  "字符串哈希": {
    "content": "struct StringHash {\r\n    static constexpr int B = 131;\r\n    static constexpr array<int, 2> M = { 1000000021, 1000000453 };\r\n    array<vector<int>, 2> h, b;\r\n    StringHash() {}\r\n    StringHash(const string&amp; s) { init(s); }\r\n    void init(const string&amp; s) {\r\n        int n = s.size();\r\n        for (int j = 0; j < 2; j++) {\r\n            h[j].resize(n + 1), b[j].resize(n + 1, 1);\r\n        }\r\n        for (int j = 0; j < 2; j++) {\r\n            for (int i = 1; i <= n; i++) {\r\n                b[j][i] = 1LL * b[j][i - 1] * B % M[j];\r\n                h[j][i] = (1LL * h[j][i - 1] * B + s[i - 1]) % M[j];\r\n            }\r\n        }\r\n    }\r\n    array<int, 2> query(int l, int r) {\r\n        array<int, 2> val;\r\n        for (int j = 0; j < 2; j++) {\r\n            val[j] = (h[j][r] - 1LL * h[j][l - 1] * b[j][r - l + 1] % M[j] + M[j]) % M[j];\r\n        }\r\n        return val;\r\n    }\r\n    bool same(int l1, int r1, int l2, int r2) {\r\n        return query(l1, r1) == query(l2, r2);\r\n    }\r\n};"
  },
  "回家前须知": {
    "content": "走之前把缪哥的宿舍钥匙给lck，电费交齐（我自己说的） 16号走 缪哥8号走"
  },
  "你好": {
    "content": "应该可以"
  },
  "瓦力战绩": {
    "content": "记录瓦力在2024年8月6日拳皇争霸赛中击败周杰成为拳皇之王"
  },
  "gaokan": {
    "content": "[CQ:image,file=807d25acf6308170225451b8d5d1a6a3.image,url=https://c2cpicdw.qpic.cn/offpic_new/3837076318//3837076318-1238138315-807D25ACF6308170225451B8D5D1A6A3/0?term=2&amp;is_origin=0]"
  },
  "线段树": {
    "content": "/*struct node{\r\n    ll l,r,val;\r\n}tree[800100];\r\nvector<ll> b;\r\nvoid push_up(int id){\r\n    tree[id].val = min(tree[id*2].val,tree[id*2+1].val);\r\n}\r\nvoid build(int id,int left,int right){\r\n    tree[id].l = left,tree[id].r = right;\r\n    if(left==right){\r\n        tree[id].val = b[left];\r\n        return;\r\n    }\r\n    int mid = (left+right)/2;\r\n    build(id*2,left,mid);\r\n    build(id*2+1,mid+1,right);\r\n    push_up(id);\r\n}\r\nvoid change(int id,int target,ll val,int op){\r\n    if(tree[id].l==tree[id].r){\r\n        if(op==0)tree[id].val = max(tree[id].val,val);\r\n        else tree[id].val = val;\r\n        return;\r\n    }\r\n    if(tree[id*2].l >= target &amp;&amp; tree[id*2].r<=target)change(id*2,target,val,op);\r\n    else change(id*2+1,target,val,op);\r\n    push_up(id);\r\n}\r\nint query(int id,int left,int right){\r\n    if(left>tree[id].r)return 1e9;\r\n    if(right<tree[id].l)return 1e9;\r\n    if(left<= tree[id].l &amp;&amp; tree[id].r <= right){\r\n        return tree[id].val;\r\n    }\r\n    return min(query(id*2,left,right),query(id*2+1,left,right));\r\n}*/"
  },
  "同构体": {
    "content": "这些人都是同构体，他们找到了自己的另一个能量块"
  },
  "python二分sqrt": {
    "content": "def sqrt(n):\r\n    if n < 0:\r\n        raise ValueError(\"输入必须是非负整数\")\r\n \r\n    if n == 0 or n == 1:\r\n        return n\r\n \r\n    # 二分查找范围是 [1, n]\r\n    start, end = 1, n\r\n    result = 1\r\n \r\n    while start <= end:\r\n        mid = (start + end) // 2\r\n        if mid * mid == n:\r\n            return mid\r\n        elif mid * mid < n:\r\n            start = mid + 1\r\n            result = mid  # 记录当前的中间值，可能是答案\r\n        else:\r\n            end = mid - 1\r\n \r\n    return result"
  }
}